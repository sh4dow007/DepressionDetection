#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 4.23a
#  in conjunction with Tcl version 8.6
#    Jun 12, 2019 10:16:36 PM IST  platform: Linux
#    Jun 13, 2019 08:16:48 PM IST  platform: Linux
#    Jun 13, 2019 09:08:31 PM IST  platform: Linux
#    Jun 13, 2019 11:19:20 PM IST  platform: Linux

import time

import speech_recognition as sr

import nltk
import re

from gtts import gTTS
import os

import sys


try:
    import Tkinter as tk
except ImportError:
    import tkinter as tk

try:
    import ttk
    py3 = False
except ImportError:
    import tkinter.ttk as ttk
    py3 = True

def write_text(temp):
    w.Text1.delete('1.0',tk.END)
    w.Text1.insert(tk.END,temp+"\n")
    w.Text1.update()

def write_result(temp):
    # w.Text1.delete('1.0', tk.END)
    w.Text2.insert(tk.END, temp+"\n")
    w.Text2.update()

def StartButton(p1):
    w.Text1.delete('1.0', tk.END)
    w.Text2.delete('1.0', tk.END)
    # tk.restart()
    driving_func()

def init(top, gui, *args, **kwargs):
    global w, top_level, root
    w = gui
    top_level = top
    root = top

def driving_func():
    init_speech(filename='SentiWordNet_3.0.0.txt', weighting='average')
    trigger = "Start depression"
    write_text("Starting... \nInitializing...")
    if not (os.path.isfile('audio9.mp3')):
        print("inside")
        init_audio()
    # while 1:
    #     if (trigger.lower()) in voice_interpreter().lower():
            # call("open /Applications/Siri.app")
    print("Hello dear, how are u doing? Please describe your day.")
    write_text("Hello dear, how are u doing? Please describe your day.")
    w.Text2.delete('1.0', tk.END)
    speak_gtts(1)
    read_statement = voice_interpreter()
        # if read_statement == "":
        #     continue
    first_ans = score(read_statement)
    analyze_tone(read_statement)
    total_sum = chatbot_reply(first_ans)
    write_result("Overall depression scale : " + str(total_sum))
    print("Overall depression scale : " + str(total_sum))
    # time.sleep(0.001)
        # break
        # exit()

def init_speech(filename='SentiWordNet_3.0.0.txt', weighting='average'):
    """Initialize with filename and choice of weighting."""
    if weighting not in ('geometric', 'harmonic', 'average'):
        raise ValueError('Allowed weighting options are geometric, harmonic, average')
    # parse file and build sentiwordnet dicts
    swn_pos = {'a': {}, 'v': {}, 'r': {}, 'n': {}}
    swn_all = {}
    build_swn(filename, weighting)

def average(score_list):
    """Get arithmetic average of scores."""
    if (score_list):
        return sum(score_list) / float(len(score_list))
    else:
        return 0

def geometric_weighted(score_list):
    """"Get geometric weighted sum of scores."""
    weighted_sum = 0
    num = 1
    for el in score_list:
        weighted_sum += (el * (1 / float(2 ** num)))
        num += 1
    return weighted_sum

# another possible weighting instead of average
def harmonic_weighted(score_list):
    """Get harmonic weighted sum of scores."""
    weighted_sum = 0
    num = 2
    for el in score_list:
        weighted_sum += (el * (1 / float(num)))
        num += 1
    return weighted_sum

swn_pos = {'a': {}, 'v': {}, 'r': {}, 'n': {}}
swn_all = {}
def build_swn(filename, weighting):
    """Build class's lookup based on SentiWordNet 3.0.0"""
    records = [line.split('\t') for line in open(filename)]
    for rec in records:
        # has many words in 1 entry
        words = rec[4].split()
        pos = rec[0]
        for word_num in words:
            word = word_num.split('#')[0]
            sense_num = int(word_num.split('#')[1])

            # build a dictionary key'ed by sense number
            if word not in swn_pos[pos]:
                swn_pos[pos][word] = {}
            swn_pos[pos][word][sense_num] = float(
                rec[2]) - float(rec[3])
            if word not in swn_all:
                swn_all[word] = {}
            swn_all[word][sense_num] = float(rec[2]) - float(rec[3])

    # convert innermost dicts to ordered lists of scores
    for pos in swn_pos.keys():
        for word in swn_pos[pos].keys():
            newlist = [swn_pos[pos][word][k] for k in sorted(
                swn_pos[pos][word].keys())]
            if weighting == 'average':
                swn_pos[pos][word] = average(newlist)
            if weighting == 'geometric':
                swn_pos[pos][word] = geometric_weighted(newlist)
            if weighting == 'harmonic':
                swn_pos[pos][word] = harmonic_weighted(newlist)

    for word in swn_all.keys():
        newlist = [swn_all[word][k] for k in sorted(
            swn_all[word].keys())]
        if weighting == 'average':
            swn_all[word] = average(newlist)
        if weighting == 'geometric':
            swn_all[word] = geometric_weighted(newlist)
        if weighting == 'harmonic':
            swn_all[word] = harmonic_weighted(newlist)

def pos_short(pos):
    """Convert NLTK POS tags to SWN's POS tags."""
    if pos in set(['VB', 'VBD', 'VBG', 'VBN', 'VBP', 'VBZ']):
        return 'v'
    elif pos in set(['JJ', 'JJR', 'JJS']):
        return 'a'
    elif pos in set(['RB', 'RBR', 'RBS']):
        return 'r'
    elif pos in set(['NNS', 'NN', 'NNP', 'NNPS']):
        return 'n'
    else:
        return 'a'

def score_word(word, pos):
    """Get sentiment score of word based on SWN and part of speech."""
    try:
        return swn_pos[pos][word]
    except KeyError:
        try:
            return swn_all[word]
        except KeyError:
            return 0

def score(sentence):
    """Sentiment score a sentence."""
    # init sentiwordnet lookup/scoring tools
    impt = set(
        ['NNS', 'NN', 'NNP', 'NNPS', 'JJ', 'JJR', 'JJS', 'RB', 'RBR', 'RBS', 'VB', 'VBD', 'VBG', 'VBN', 'VBP',
         'VBZ', 'unknown'])
    non_base = set(['VBD', 'VBG', 'VBN', 'VBP', 'VBZ', 'NNS', 'NNPS'])
    negations = set(
        ['not', 'n\'t', 'less', 'no', 'never', 'nothing', 'nowhere', 'hardly', 'barely', 'scarcely', 'nobody',
         'none'])
    stopwords = nltk.corpus.stopwords.words('english')
    wnl = nltk.WordNetLemmatizer()

    scores = []
    tokens = nltk.tokenize.word_tokenize(sentence)
    tagged = nltk.pos_tag(tokens)

    index = 0
    for el in tagged:

        pos = el[1]
        try:
            word = re.match('(\w+)', el[0]).group(0).lower()
            start = index - 5
            if start < 0:
                start = 0
            neighborhood = tokens[start:index]

            # look for trailing multiword expressions
            word_minus_one = tokens[index - 1:index + 1]
            word_minus_two = tokens[index - 2:index + 1]

            # if multiword expression, fold to one expression
            if (is_multiword(word_minus_two)):
                if len(scores) > 1:
                    scores.pop()
                    scores.pop()
                if len(neighborhood) > 1:
                    neighborhood.pop()
                    neighborhood.pop()
                word = '_'.join(word_minus_two)
                pos = 'unknown'

            elif (is_multiword(word_minus_one)):
                if len(scores) > 0:
                    scores.pop()
                if len(neighborhood) > 0:
                    neighborhood.pop()
                word = '_'.join(word_minus_one)
                pos = 'unknown'

            # perform lookup
            if (pos in impt) and (word not in stopwords):
                if pos in non_base:
                    word = wnl.lemmatize(word, pos_short(pos))
                score = score_word(word, pos_short(pos))
                if len(negations.intersection(set(neighborhood))) > 0:
                    score = -score
                scores.append(score)

        except AttributeError:
            pass

        index += 1

    if len(scores) > 0:
        return sum(scores) / float(len(scores))
    else:
        return 0

def is_multiword(words):
    """Test if a group of words is a multiword expression."""
    joined = '_'.join(words)
    return joined in swn_all

def voice_interpreter():
    # enter the name of usb microphone that you found
    # using lsusb
    # the following name is only used as an example
    mic_name = "USB Device 0x46d:0x825: Audio (hw:1, 0)"
    # Sample rate is how often values are recorded
    sample_rate = 48000
    # Chunk is like a buffer. It stores 2048 samples (bytes of data)
    # here.
    # it is advisable to use powers of 2 such as 1024 or 2048
    chunk_size = 2048

    # Initialize the recognizer
    r = sr.Recognizer()

    # generate a list of all audio cards/microphones
    mic_list = sr.Microphone.list_microphone_names()

    # the following loop aims to set the device ID of the mic that
    # we specifically want to use to avoid ambiguity.
    for i, microphone_name in enumerate(mic_list):
        if microphone_name == mic_name:
            device_id = i

    # use the microphone as source for input. Here, we also specify
    # which device ID to specifically look for in case the microphone
    # is not working, an error will pop up saying "device_id undefined"
    with sr.Microphone(sample_rate=sample_rate,
                       chunk_size=chunk_size) as source:
        # wait for a second to let the recognizer adjust the
        # energy threshold based on the surrounding noise level
        r.adjust_for_ambient_noise(source)
        print("*listening")
        write_text("*listening")
        # listens for the user's input
        audio = r.listen(source)

        try:
            statement = r.recognize_google(audio)
            write_text("you said: " + statement)
            print("you said: " + statement)
            return statement

        # error occurs when google could not understand what was said
        except sr.UnknownValueError:
            write_text("Could not understand audio")
            print("Could not understand audio")
            return ""
            # exit()

        except sr.RequestError as e:
            write_text("Could not request results from Speech Recognition service; {0}".format(e))
            print("Could not request results from Speech Recognition service; {0}".format(e))
            exit()

def analyze_tone(read_data):
    # The ToneAnalyzer class from WDC
    from watson_developer_cloud import ToneAnalyzerV3

    # -------------------------------------------------------------------------
    # Instantiate TA Object with my Credentials
    # -------------------------------------------------------------------------
    tone_analyzer = ToneAnalyzerV3(
        iam_apikey="wN3kBNH9MJcyo7LDKBlrq2mmSbupCTnhC_hugTWgoa55",
        version='2018-02-16',
        url='https://gateway-lon.watsonplatform.net/tone-analyzer/api'
    )

    # -------------------------------------------------------------------------

    # Pass a single review to TA (one by one):

    json_output = tone_analyzer.tone(read_data, content_type='text/plain')

    result = json_output.result
    for i in result['document_tone']['tones']:
        if i is None:
            break
        if i['tone_name'] not in ("Analytical", "Tentative", "Confident"):
            write_result(i['tone_name'] + ": " + str(i['score'] * 100) + "%")
            print(i['tone_name'] + ": " + str(i['score'] * 100) + "%")
        # print(i['score'])

    # ------------------------------------------------------------------------

def init_audio():
    tts = gTTS(text="Hello dear, how are u doing? Please describe your day.", lang='en')
    tts.save("audio1.mp3")
    tts = gTTS(text="It seems unpleasant. Tell me more about it", lang='en')
    tts.save("audio2.mp3")
    tts = gTTS(text="It seems you are not happy. Try sharing your problem with your loved ones.", lang='en')
    tts.save("audio3.mp3")
    tts = gTTS(text="Hope you are feeling better now.", lang='en')
    tts.save("audio4.mp3")
    tts = gTTS(text="You seem a bit off. Tell me more about it.", lang='en')
    tts.save("audio5.mp3")
    tts = gTTS(text="You are a bit upset. don't worry you would be better", lang='en')
    tts.save("audio6.mp3")
    tts = gTTS(text="You seem in a pleasant mood!", lang='en')
    tts.save("audio8.mp3")
    tts = gTTS(text="You seem to be in a good mood. Enjoy your day!", lang='en')
    tts.save("audio9.mp3")

def speak_gtts(mp3_sequence):
    if mp3_sequence == 1:
        os.system('mpg321 audio1.mp3 -quiet')
    elif mp3_sequence == 2:
        os.system('mpg321 audio2.mp3 -quiet')
    elif mp3_sequence == 3:
        os.system('mpg321 audio3.mp3 -quiet')
    elif mp3_sequence == 4 or mp3_sequence == 7:
        os.system('mpg321 audio4.mp3 -quiet')
    elif mp3_sequence == 5:
        os.system('mpg321 audio5.mp3 -quiet')
    elif mp3_sequence == 6:
        os.system('mpg321 audio6.mp3 -quiet')
    elif mp3_sequence == 8:
        os.system('mpg321 audio8.mp3 -quiet')
    elif mp3_sequence == 9:
        os.system('mpg321 audio9.mp3 -quiet')

def chatbot_reply(first_ans):
    write_result("sentiment score: " + str(first_ans))
    print("sentiment score: " + str(first_ans))
    sum = first_ans
    if -1 <= first_ans < -0.20:
        write_text("It seems unpleasant. Tell me more about it.")
        print("It seems unpleasant. Tell me more about it.")
        speak_gtts(2)
        read_statement = voice_interpreter()
        second_neg_ans = score(read_statement)
        write_result("sentiment score: " + str(second_neg_ans))
        print("sentiment score: " + str(second_neg_ans))
        if read_statement == "":
            return
        analyze_tone(read_statement)
        sum += second_neg_ans

        if -1.0 <= second_neg_ans < 0.0:
            write_text("It seems you are not happy. Try sharing your problem with your loved ones.")
            print("It seems you are not happy. Try sharing your problem with your loved ones.")
            speak_gtts(3)

        else:
            write_text("Hope you are feeling better now.")
            print("Hope you are feeling better now.")
            speak_gtts(4)

    elif -0.20 < first_ans < 0.10:
        write_text("You seem a bit off... Tell me more about it.")
        print("You seem a bit off... Tell me more about it.")
        speak_gtts(5)
        read_statement = voice_interpreter()
        second_ans = score(read_statement)
        write_result("sentiment score: " + str(second_ans))
        print("sentiment score: " + str(second_ans))
        if read_statement == "":
            return
        analyze_tone(read_statement)
        sum += second_ans

        if -1.0 <= second_ans < 0.0:
            write_text("You are a bit upset, don't worry you would be better.")
            print("You are a bit upset, don't worry you would be better.")
            speak_gtts(6)

        else:
            write_text("Hope you are feeling better now.")
            print("Hope you are feeling better now.")
            speak_gtts(7)

    elif 0.10 < first_ans < 0.40:
        write_text("You seem in a pleasant mood!")
        print("You seem in a pleasant mood!")
        speak_gtts(8)

    elif 0.40 < first_ans <= 1.0:
        write_text("You seem to be in a good mood. Enjoy your day!!")
        print("You seem to be in a good mood. Enjoy your day!!")
        speak_gtts(9)

    return sum

def destroy_window():
    # Function which closes the window.
    global top_level
    top_level.destroy()
    top_level = None

if __name__ == '__main__':
    import DocDep
    DocDep.vp_start_gui()




